<hr></hr><p>title: M-DOT</p><p>subtitle: CSCE 336 Embedded Systems // Project 2 Report</p><p>author: Carston Wiebe</p><p>date: May 9, 2025</p><p>numbersections: true</p><p>colorlinks: true</p><p>links-as-notes: true</p><p>toc: true</p><p>header:</p><p>  right: University of Nebraska-Lincoln</p><p>toc-on-own-page: true</p><p>margin-top: 1.2in</p><p>margin-bottom: 1.2in</p><p>margin-left: 1.2in</p><p>margin-right: 1.2in</p><p>fontfamily: tgschola</p><p>fontsize: 11pt</p><hr></hr><h1>Introduction</h1><p>M-DOT is a Arduino-based maze-navigating robot car programmed using ATmega328P</p><p>registers and a custom library.  It uses two DC motors controlled by a L298</p><p>motor driver to maneuver, along with an HC-SR04 ultrasonic sensor mounted to a</p><p>SG90 servo to <q>see</q> its surroundings.  The goal of the project is to create a</p><p>robot car that can successfully navigate a maze-like obstacle course using its</p><p>onboard sensor.</p><p>Additionally, M-DOT can be controlled remotely using an AX-1838HS IR receiver</p><p>and Elegoo controller. This functionality is <i>not</i> used in maze navigation —</p><p>that is totally autonomous.</p><h1>Preliminary Design</h1><p>The robot has four main external components that need to be configured: The</p><p>servo, the sonar (ultrasonic sensor), the drivetrain (DC motors), and the (IR)</p><p>receiver.  They are</p><p>connected to the Arduino UNO as seen in Figure \ref{initial}</p><p>!<a href="./images/initial.png">Initial design schematic. \label{initial}</a>{width=50%}</p><p>All three timers are used in configuring these components, as seen in Table</p><dt>\ref{timers}.</dt><dd>Timer configurations. \label{timers}</dd><p>| Timer    | Purpose        | Mode              | Output(s)      |</p><p>| ——– | ————– | —————– | ————– |</p><p>| <code>timer0</code> | Servo PWM      | Phase correct PWM | <code>OC0B</code>         |</p><p>| <code>timer1</code> | General timer  | Normal            | None           |</p><p>| <code>timer2</code> | Drivetrain PWM | Phase correct PWM | <code>OC2A`, </code>OC2B` |</p><h2>Servo Configuration</h2><p>In order to generate a PWM with the duty cycle and period expected by the SG90</p><p>servo, <code>timer0</code> was configured to use <code>OCR0A</code> as its TOP, the value of which</p><p>can be found with equation:</p><p>$$ \mathrm{TOP} = \mathrm{OCR0A} = \frac{\mathrm{CPU~frequency} \times</p><p>\mathrm{servo~period}}{\mathrm{prescaler} \times 2} = 156.25 \approx 156 $$</p><p>where:</p><p>\begin{alignat*}{3}</p><p>\mathrm{CPU~frequency} &amp;= 16 \u{MHz} \\</p><p>\mathrm{servo~period} &amp;= 20 \u{ms} \\</p><p>\mathrm{prescaler} &amp;= 1024</p><p>\end{alignat*}</p><p>Since <code>OCR0A</code> is being used as TOP, the PWM is generated on <code>OC0B</code>.</p><h2>General Timer Configuration</h2><p>General timer functions — such as those needed by the sonar — are provided</p><p>by <code>timer1</code>.  To this end, the timer is configured in normal mode with no major</p><p>modifications.  The timer does, however, make use of two interrupts:</p><li type="ordered">The timer overflow interrupt, <code>TOV1</code>, which will be used to increment a</li><p>    counter and track large spans of time.</p><li type="ordered">The output compare A interrupt, <code>OCIE1A</code>, which will be used by the</li><p>    receiver to determine when a data packet <q>times out</q>.</p><h2>Sonar Configuration</h2><p>The sonar uses two non-PWM pins — one output (trigger) and one input (echo)</p><p>— along with basic timer functions to measure signal lengths.</p><p>A reading begins by sending a ten microsecond pulse to the trigger.  The</p><p>duration of the return signal recieved on echo is then measured and used to</p><p>calculate the distance, using the equation:</p><p>$$ \mathrm{distance} \u{cm} = \mathrm{echo~duration}\u{\mu s} \times</p><p>\frac{\mathrm{centimeters}}{\mathrm{microsecond}} $$</p><p>where:</p><p>$$ \frac{\mathrm{centimeters}}{\mathrm{microsecond}} = 58 $$</p><p>Readings should be taken at least 60 milliseconds apart to prevent noise from</p><p>interfering with the measurement.</p><h2>Drivetrain Configuration</h2><p>Each drivetrain motor is hooked into the L298 motor driver with two pins. The</p><p>Arduino itself is connected to the L298 using a three-wire interface (three</p><p>pins per motor):</p><li type="unordered">One wire is a PWM that connects to the motor enable pin and controls the</li><p>  <q>power</q> of the motor.</p><li type="unordered">The other two (non-PWM) wires control the direction of the motor.  When one</li><p>  pin is HIGH and the other LOW, the motor spins one way; swap which pin is</p><p>  HIGH and which is LOW to spin the motor the other way.  Set both pins equal</p><p>  to each other to <q>brake</q> the motor.</p><p><code>timer2</code> is used to generate the PWM signals needed for both motor enable</p><p>wires.  These are generated on pins <code>OC2A` and </code>OC2B`.</p><h2>Receiver Configuration</h2><p>The IR receiver will be hooked up to an external interrupt (which is idle HIGH)</p><p>so as to prevent the need for constant polling.  It will use <code>timer1</code> as a</p><p>pseudo watchdog timer by enabling and disabling an output compare match</p><p>interrupt.</p><p>The following process is used to receive data, which it stores in a</p><p>global "data packet":</p><li type="ordered">The external interrupt ISR is configured to fire on the falling edge,</li><p>    but that trigger will toggle between falling and rising edges each time it</p><p>    is called.</p><li type="ordered">When a falling edge interrupt fires, the current timer count is stored in</li><p>    the data packet and the watchdog timer is disabled, if it isn't already.</p><li type="ordered">When the rising edge interrupt fires, the timer count is cleared and the</li><p>    watchdog timer is started.  If the watchdog timer terminates, the data</p><p>    packet is marked as complete and the process is reset.</p><p>Each data packet sent will begin with a start bit, followed by 32 data bits,</p><p>and terminating with an end bit.  Each bit will consist of a "low half-bit" and</p><p>a "high half-bit".  The low half of the data bits is used to separate the high</p><p>halves, which will contain the actual data:  A long time spent high is a</p><p>logical 1, and a short time high is a logical 0.  The time spent low is</p><p>funtionally irrevelent.  Recorded times for the various half-bits can be seen</p><dt>in Table \ref{lengths}.</dt><dd>Recorded half-bit lengths.</dd><p>\label{lengths}</p><p>| Type        | Time [ms] |</p><p>| ———– | ——–: |</p><p>| Start low   |     9.336 |</p><p>| Start high  |     4.456 |</p><p>| Data X low  |     0.644 |</p><p>| Data 0 high |     0.504 |</p><p>| Data 1 high |     1.592 |</p><p>| Stop low    |     0.656 |</p><p>| Stop high   |    39.992 |</p><p>In order to properly identify 1's and 0's in the data segement, additional</p><p>analysis was conducted, as seen in Table \ref{stats}.  The valid range</p><p>displayed in the table is the range that will correctly identify 99.9999426697%</p><dt>of pulses (plus or minus five standard deviations).</dt><dd>Average, standard deviation, and valid ranges for data half-bits.</dd><p>\label{stats}</p><p>| Type        | Avg [ms] | Stdev [$\mu$s] |     Range [ms] |</p><p>| ———– | ——-: | ————-: | ————-: |</p><p>| Data X low  |    0.661 |          16.60 | 0.578 to 0.744 |</p><p>| Data 0 high |    0.506 |           2.14 | 0.495 to 0.517 |</p><p>| Data 1 high |    1.592 |           9.90 | 1.542 to 1.641 |</p><p>With that, various buttons on the Elegoo IR controller were mapped to their</p><dt>corresponding hex codes, and can be seen in Table \ref{buttons}.</dt><dd>Recognized buttons.</dd><p>\label{buttons}</p><p>| Button         |     Hex code |</p><p>| ————– | ———–: |</p><p>| <code>POWER</code>        | <code>0x00FFA25D</code> |</p><p>| <code>VOL+</code>         | <code>0x00FF629D</code> |</p><p>| <code>FUNC/STOP</code>    | <code>0x00FFE21D</code> |</p><p>| <code>FAST BACK</code>    | <code>0x00FF22DD</code> |</p><p>| <code>PAUSE</code>        | <code>0x00FF02FD</code> |</p><p>| `FAST FORWARD<code> | </code>0x00FFC23D` |</p><p>| <code>DOWN</code>         | <code>0x00FFE01F</code> |</p><p>| <code>VOL-</code>         | <code>0x00FFA857</code> |</p><p>| <code>UP</code>           | <code>0x00FF906F</code> |</p><p>| <code>EQ</code>           | <code>0x00FF9867</code> |</p><h1>Software Implementation</h1><p>M-DOT is programmed with a conceptually simple algorithm — Algorithm</p><p>\ref{main} — which navigates by taking sonar measurements while stationary</p><p>and moving in discrete bursts based on those measurements.  The four <q>cases</q></p><p>for how it moves are:</p><li type="ordered">*If an object is in the immediate drive path,* pivot 90 degrees away from</li><p>    the wall.</p><li type="ordered">*Else if the wall is too close,* curve away from it.</li><li type="ordered">*Else if the wall is very far (twice the ideal distance),* curve sharply</li><p>    towards the wall.</p><li type="ordered"><i>Else,</i> curve towards the wall.</li><p>The algorithm is designed so that there is not a hard-coded "target distance"</p><p>from the wall that M-DOT tries to reach — rather, the robot will measure its</p><p>initial distance from the wall on start-up and then try and maintain that</p><p>distance throughout its travels.</p><p>\begin{algorithm}</p><p>\caption{M-DOT's primary process. \label{main}}</p><p>\Fn{$\alfn{Navigate}$}{</p><p>  $idealDistance \gets \mathrm{measure<sub>distance</sub>to~wall}$\;</p><p>  \While{$true$}{</p><p>    $wallMargin \gets \textsc{CheckWall}(idealDistance)$\;</p><p>    $frontMargin \gets \textsc{CheckFront}(idealDistance)$\;</p><p>    \uIf{$frontMargin &lt; 0$}{</p><p>      $\mathrm{pivot<sub>90~degrees</sub>from~wall}$\;</p><p>    }\uElseIf{$wallMargin &lt; 0$}{</p><p>      $\mathrm{curve<sub>away~from</sub>wall}$\;</p><p>    }\uElseIf{$wallMargin &gt; idealDistance$}{</p><p>      $\mathrm{curve<sub>sharply</sub>towards~wall}$\;</p><p>    }\Else{</p><p>      $\mathrm{curve<sub>towards</sub>wall}$\;</p><p>    }</p><p>    $\mathrm{brake<sub>the</sub>robot}$\;</p><p>  }</p><p>}</p><p>\end{algorithm}</p><p>$\textsc{CheckWall}$ and $\textsc{CheckFront}$ (Algorithms \ref{wall} and</p><p>\ref{front}) are two near-identical processes that simply return the difference</p><p>between the ideal distance and the current following distance, as measured from</p><p>both the side and the front.</p><p>\begin{algorithm}</p><p>\caption{Measures the distance to the wall. \label{wall}}</p><p>\Fn{$\alfn{CheckWall}(idealDistance)$}{</p><p>  $currentDistance \gets \mathrm{measure<sub>distance</sub>to~wall}$\;</p><p>  \Return{$currentDistance - idealDistance$}</p><p>}</p><p>\end{algorithm}</p><p>\begin{algorithm}</p><p>\caption{Measures the distance to the nearest obstacle. \label{front}}</p><p>\Fn{$\alfn{CheckFront}(idealDistance)$}{</p><p>  $currentDistance \gets \mathrm{measure<sub>distance</sub>to~front}$\;</p><p>  \Return{$currentDistance - idealDistance$}</p><p>}</p><p>\end{algorithm}</p><p>M-DOT also features a much faster wall-following algorithm, Algorithm</p><p>\ref{algo}, that is an alternative to $\textsc{Navigate}$ as a program "entry</p><p>point".  This method does not account for obstacles in the drive path, but</p><p>neither does it constantly start and stop.</p><p>\begin{algorithm}</p><p>\caption{A simple wall-following algorithm for M-DOT. \label{algo}}</p><p>\Fn{$\alfn{FollowWall}$}{</p><p>  $idealDistance \gets \mathrm{measure<sub>the</sub>distance<sub>to~the</sub>wall}$\;</p><p>  $tolerance \gets \mathrm{acceptable<sub>margin~of</sub>error}$\;</p><p>  \While{$true$}{</p><p>    $currentDistance \gets \mathrm{measure<sub>the</sub>distance<sub>to~the</sub>wall}$\;</p><p>    \uIf{$currentDistance &gt; idealDistance + tolerance$}{</p><p>      drive curving towards the wall\;</p><p>    }\uElseIf{$currentDistance &lt; idealDistance - tolerance$}{</p><p>      drive curving away from the wall\;</p><p>    }\Else{</p><p>      drive straight ahead\;</p><p>    }</p><p>  }</p><p>}</p><p>\end{algorithm}</p><h1>Hardware Implementation</h1><p>M-DOT is constructed in accordance with the initial design schematic seen in</p><p>Figure \ref{initial} (which is also the final hardware schematic), with the pin</p><dt>assignments seen in Table \ref{pins}.</dt><dd>Pin assignments. \label{pins}</dd><p>| Component      | Arduino Pin | ATmega328P Pin | Special Function |</p><p>| ————– | ———-: | ————-: | —————- |</p><p>| Servo control  |           5 |          <code>PD5` | </code>OC0B`           |</p><p>| Sonar trigger  |           7 |          <code>PD7</code> |                  |</p><p>| Sonar echo     |           8 |          <code>PB0</code> |                  |</p><p>| Motor A enable |          11 |          <code>PB3` | </code>OC2A`           |</p><p>| Motor A +      |           6 |          <code>PD6</code> |                  |</p><p>| Motor A –     |           4 |          <code>PD4</code> |                  |</p><p>| Motor B enable |           3 |          <code>PD3` | </code>OC2B`           |</p><p>| Motor B +      |          10 |          <code>PB2</code> |                  |</p><p>| Motor B –     |           9 |          <code>PB1</code> |                  |</p><p>| Error report   |          13 |          <code>PB5</code> | Built-in LED     |</p><p>| IR signal      |           2 |          <code>PD2` | </code>INT0`           |</p><p>The sonar should be angled on its servo so that it is always facing a surface</p><p>head-on.  This is because the wave sent out by the sonar needs to bounce of the</p><p>surface and return — if the surface is at an angle away from the sonar, the</p><p>wave can bounce away and never return, as seen in Figure \ref{bounce}.</p><p>![If the sonar is at too large an angle with the surface it is facing, the</p><p>return signal could bounce away. \label{bounce}](./images/bounce.png){</p><p>width=70% }</p><p>However, if the sonar is measuring along M-DOT's center of rotation then it may</p><p>not detect the robot drifting off-course quick enough to prevent that angle</p><p>from growing dangerous, as seen in Figure \ref{axis}.</p><p>To this end, the sonar is kept at a 30 degree offset from the wall, as seen in</p><p>Figure \ref{offset} — large enough to detect alterations to M-DOT's drive</p><p>path early, but small enough to still receive a return wave that can measured</p><p>with confidence.</p><p>\begin{figure}[!tbp]</p><p>  \centering</p><p>  \begin{minipage}[t]{0.45\textwidth}</p><p>    \includegraphics[width=\textwidth]{./images/axis.png}</p><p>    \caption{The measured distance does not differ much between the two points</p><p>    when measuring along the center of rotation.}</p><p>    \label{axis}</p><p>  \end{minipage}</p><p>  \hfill</p><p>  \begin{minipage}[t]{0.45\textwidth}</p><p>    \includegraphics[width=\textwidth]{./images/offset.png}</p><p>    \caption{There is a much more noticeable difference between the measured</p><p>    distances when measuring at an offset.}</p><p>    \label{offset}</p><p>  \end{minipage}</p><p>\end{figure}</p><h1>Testing</h1><h2>Debugging</h2><p>There were a few issues encountered during the testing process that had to be</p><p>debugged, all of which concerned the sonar.  First and foremost among them was</p><p>the fact that the sonar could not get a reading from an angled surface, which</p><p>was not considered during the preliminary design and had to be adjusted for</p><p>when implementing and testing the project.</p><p>The other major hiccup was that the `getSonarDistance()` function (initially)</p><p>did not force the 60 millisecond measurement cycle itself, so it was easy to</p><p>forget and try to take back-to-back measurements.</p><p>Both of these issues where debugged by simply taking measurements with the</p><p>sonar and printing them to the serial monitor in a loop while observing the</p><p>output.</p><hr></hr><p>Other design challenges that were encountered (but that are not considered</p><p><q>bugs</q> per se) include:</p><li type="unordered">A relatively slow angular velocity on the servo, which forced ~500</li><p>  millisecond measurement cycles when watching both the front and the side —</p><p>  200ms per turn and 60ms per sonar reading.  This made moving while measuring</p><p>  dangerous at any appreciable speed in the full navigation algorithm.</p><li type="unordered">Inaccurate sonar measurements while moving, which further encouraged using</li><p>  the sonar while stationary.</p><li type="unordered">Drivetrain drift that varied based on how hot the motors are, which</li><p>  discouraged using precise powers to drive the motors.</p><h2>Testing Methodology</h2><p>Testing of M-DOT happened in multiple stages:</p><li type="ordered">Each component was tested individually to confirm basic functionality, e.g.</li><p>    checking to make sure the servo spins and the sonar returns an accurate</p><p>    distance.</p><li type="ordered">The drivetrain was tested for drift by driving it straight forward at max</li><p>    speed and observing its path.</p><li type="ordered">The range of angles at which the sonar can get a valid reading was measured</li><p>    by taking readings at increasing angles until the output became unreliable.</p><li type="ordered">The full program was then tested in various environments (carpeted floors</li><p>    vs. smooth floors, varying initial distances from the wall, etc.).</p><h2>Results</h2><p>Each component was able to perform its basic functionality without trouble,</p><p>though the drivetrain as a whole did drift to the right by a not insignificant</p><p>amount.  This was corrected for in the code by reducing the power sent to the</p><p>left motor by five percent at all times.  The sonar was found to be able to</p><p>take accurate measurements up to around a 30 degree offset from the opposite</p><p>surface, at which point the measurements became unusable.</p><p>M-DOT then completed several tests verifying the functionality of its</p><p>navigation algorithms, such as [following a</p><p>wall](https://www.youtube.com/watch?v=LuJOR8e18cY) with the simplified</p><p>algorithm and [navigating a small</p><p>course](https://www.youtube.com/watch?v=sb-tt6APl8w) with the full algorithm.</p><h1>Q&amp;A</h1><h2>Motor Driver</h2><dt>How are the motors wired up?  Is it a two or three wire interface?</dt><dd>The motors themselves are hooked into the L298 motor driver with two pins</dd><p>each. The Arduino is connected to the L298 using a three-wire interface (three</p><p>pins per motor): one PWM pin specifying speed, and two pins controlling</p><p>direction.</p><dt>What will be done with the motor enable pins?</dt><dd>The motor enable pins are connected to PWM signals and used to control the</dd><p>speed of the motors.</p><dt>What pins/timer will create the PWM signals?</dt><dd>The PWM signals will be generated on pins <code>OC2A</code> (Pin 11) and <code>OC2B</code> (Pin 3)</dd><p>using <code>timer2</code>.</p><dt>How will the motors change direction?</dt><dd>The direction of the motors will be controlled by the non-PWM pins in the</dd><p>three-wire interface — when one pin is HIGH and the other LOW, the motors</p><p>spin forward; swap which pin is HIGH and which is LOW to spin backwards.</p><h2>IR Receiver</h2><dt>How long does <code>timer1</code> take to roll over?</dt><dd>Overflows take 262.14 milliseconds in my implementation.</dd><dt>How long does a timer count last with a prescaler of 64?</dt><dd>Given the CPU frequency of 16 megahertz on the Arduino UNO, each count will</dd><p>last four microseconds.</p><dt>How long are the pulses generated by the IR remote?</dt><dd>Pulse lengths can be seen in Table \ref{lengths}.</dd><dt>What is the average/standard deviation of each pulse type?</dt><dd>Statistical analysis on pulse lengths can be seen in Table \ref{stats}.</dd><dt>What are the hex codes for the buttons on the IR remote?</dt><dd>Button codes can be seen in Table \ref{buttons}.</dd><h1>Conclusion</h1><p>The drivetrain, servo, sonar, and receiver were all successfully configured to</p><p>maneuver M-DOT and take accurate distance measurements — without using the</p><p>Arduino library. With these components, the robot was able to demonstrate</p><p>wall-following and maze-navigation capabilities, culminating in two runs</p><p>demonstrating full navigation:  One with [smoother, safer, and slower</p><p>defaults](https://www.youtube.com/watch?v=uleEuvvNTLQ), and one with [a little</p><p>more speed and a little more</p><p>sway](https://www.youtube.com/watch?v=FaIQ-QEpM34).</p><h1>Documentation</h1><p>No collaboration.</p><p>Resources used:</p><li type="unordered">Various datasheets for the ATmega328P, HC-SR04, L298, SG90, and AX-1883HS.</li><li type="unordered">Schematic for the Arduino UNO.</li><li type="unordered"><a href="https://fritzing.org">Fritzing</a> for wiring diagrams.</li><li type="unordered">CSCE 336 resources such as slides and recorded videos.</li>
